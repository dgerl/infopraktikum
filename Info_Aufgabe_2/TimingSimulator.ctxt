#BlueJ class context
comment0.target=TimingSimulator
comment0.text=\r\n\ Klasse\ TimingSimulator\ ist\ ein\ Logiksimulator,\ der\ nur\ \r\n\ Nand-Gatter\ simulieren\ kann\ und\ Zeitverz\uFFFDgerungen\ ber\uFFFDcksichtigt.\r\n\ Die\ zu\ simulierende\ Schaltung\ wird\ in\ der\ Methode\r\n\ <CODE>buildCircuit()</CODE>\ der\r\n\ Klasse\ erzeugt.\r\n\ Es\ handelt\ sich\ hierbei\ um\ ein\ einfaches\ RS-FlipFlop.\r\n\ Nach\ der\ Konstruktion\ der\ Schaltung\ muss\ zun\uFFFDchst\ der\ Ruhezustand\r\n\ der\ Schaltung\ berechnet\ werden.\ Dies\ \uFFFDbernimmt\ die\ Methode\r\n\ <CODE>findSteadyState()</CODE>.\ Die\ Eingabe-Events\ zur\ Stimulation\ der\ Schaltung\ werden\ durch\ die\ Methode\r\n\ <CODE>setInputEvents()</CODE>\ erzeugt.\r\n\ Zum\ Testen\ Ihrer\ Klassen\ <CODE>Nand</CODE>,\ <CODE>Signal</CODE>,\r\n\ <CODE>Event</CODE>,und\ <CODE>EventQueue</CODE>\ m\uFFFDssen\ Sie\r\n\ einfach\ nur\ eine\ Instanz\ dieser\ Klasse\ erzeugen\ und\ dann\ die\ Methode\r\n\ <CODE>simulate()</CODE>\ aufrufen.\r\n\ @author\ Christian\ Hochberger,\ TU\ Dresden\r\n\ @version\ 1.0\ Erste\ Fassung\r\n
comment1.params=
comment1.target=TimingSimulator()
comment1.text=\r\n\ Konstruktor,\ der\ die\ zu\ simulierende\ Schaltung\ aufbaut,\ den\ Ruhezustand\r\n\ ermittelt\ und\ die\ Eingabe-Events\ erzeugt.\r\n\ Simuliert\ wird\ ein\ einfaches\ RS-FlipFlop.\r\n
comment2.params=
comment2.target=void\ buildCircuit()
comment2.text=\r\n\ Diese\ Methode\ konstruiert\ die\ Schaltung.\ Die\ erzeugten\ Gatter\ und\ die\r\n\ inneren\ Signale\ sind\ nur\ in\ dieser\ Methode\ bekannt,\ da\ sie\ im\ Verlauf\r\n\ der\ Simulation\ implizit\ durch\ die\ Events,\ bzw.\ die\ Signale\ angesprochen\r\n\ werden.\ \r\n
comment3.params=
comment3.target=void\ findSteadyState()
comment3.text=\r\n\ Diese\ Methode\ ermittelt\ den\ Ruhezustand\ der\ Schaltung.\ Dazu\ werden\r\n\ vern\uFFFDnftige\ Initialwerte\ an\ die\ Eing\uFFFDnge\ angelegt.\ Diese\ Initialwerte\r\n\ m\uFFFDssen\ mindestens\ einmal\ durch\ die\ Schaltung\ propagiert\ werden,\r\n\ bis\ sich\ ein\ stabiler\ Zustand\ einstellt.\ Um\ das\ festzustellen\ gibt\r\n\ es\ verschiedene\ Methoden\ (im\ Gatter\ mitz\uFFFDhlen,\ wie\ oft\ sich\ der\ Wert\r\n\ \uFFFDndert.\ Im\ Signal\ mitz\uFFFDhlen,\ wie\ oft\ es\ ge\uFFFDndert\ wurde).\r\n\ Bei\ diesem\ Propagieren\ darf\ nat\uFFFDrlich\ nicht\ mit\ den\ Zeitverz\uFFFDgerungen\r\n\ gearbeitet\ werden.\ \ Sie\ k\uFFFDnnen\ also\ im\ Grunde\ die\ Wert-Propagierung\r\n\ aus\ der\ ersten\ Teilaufgabe\ benutzen.\r\n
comment4.params=
comment4.target=void\ setInputEvents()
comment4.text=\r\n\ Diese\ Methode\ erzeugt\ eine\ Reihe\ von\ Eingabe-Events,\ die\ dann\ zur\r\n\ Stimulation\ der\ Schaltung\ dienen.\ \ Die\ Events\ werden\ durch\ ihren\r\n\ eigenen\ Konstruktor\ in\ die\ EventQueue\ eingetragen,\ so\ dass\ hier\ nur\r\n\ das\ Erzeugen\ der\ Events\ zu\ sehen\ ist.\r\n\ Jedes\ Event\ bekommt\ beim\ Erzeugen\ das\ betroffene\ Signal,\ den\ Zeitpunkt\r\n\ und\ den\ <bold>neuen\ Wert</bold>\ mit.\r\n
comment5.params=
comment5.target=void\ simulate()
comment5.text=\r\n\ Diese\ Methode\ f\uFFFDhrt\ die\ eigentliche\ Simulation\ durch.\ Dazu\ wird\r\n\ gepr\uFFFDft,\ ob\ in\ der\ EventQueue\ noch\ weitere\ Events\ vorhanden\ sind.\ Ist\r\n\ dies\ der\ Fall,\ dann\ wird\ das\ n\uFFFDchste\ anstehende\ Event\ behandelt.\ Dazu\r\n\ muss\ das\ Event\ die\ Methode\ propagate()\ zur\ Verf\uFFFDgung\ stellen,\ die\r\n\ dann\ das\ betroffene\ Signal\ informiert.\r\n
comment6.params=args
comment6.target=void\ main(java.lang.String[])
comment6.text=\r\n\ Main\ Methode\ dieser\ Klasse.\ Sie\ m\uFFFDssen\ das\ im\ Moment\ noch\ nicht\r\n\ verstehen.\ Diese\ Methode\ wird\ ben\uFFFDtigt,\ wenn\ Sie\ den\ Simulator\ ohne\r\n\ BlueJ\ laufen\ lassen\ wollen.\ Wenn\ Sie\ diese\ Klasse\ in\ BlueJ\ nutzen,\r\n\ dann\ ignorieren\ Sie\ diese\ Methode\ einfach.\r\n
numComments=7
