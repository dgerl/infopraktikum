#BlueJ class context
comment0.target=FullTimingSimulator
comment0.text=\r\n\ Klasse\ FullTimingSimulator\ ist\ ein\ Logiksimulator,\ der\ alle\ geforderten\ Gattertypen\r\n\ benutzt\ und\ Zeitverz\uFFFDgerungen\ ber\uFFFDcksichtigt.\r\n\ Die\ zu\ simulierende\ Schaltung\ wird\ in\ der\ Methode\r\n\ <CODE>buildCircuitX()</CODE>\ der\ Klasse\ erzeugt\ (mit\ X\ in\ 1,2,3).\r\n\ Diese\ Methode\ verwendet\ weitere\ Hilfsmethoden\ um\ die\ Schaltung\ zu\r\n\ erzeugen.\ \ Versuchen\ Sie\ doch\ mal\ herauszubekommen,\ was\ die\ Schaltung3\r\n\ macht\ und\ bis\ zu\ welcher\ Taktfrequenz\ sie\ zuverl\uFFFDssig\ arbeitet.\r\n\ <BR>Nach\ der\ Konstruktion\ der\ Schaltung\ muss\ zun\uFFFDchst\ der\ Ruhezustand\r\n\ der\ Schaltung\ berechnet\ werden.\ Dies\ \uFFFDbernimmt\ die\ Methode\r\n\ <CODE>findSteadyStateX()</CODE>.\ Die\ Eingabe-Events\ zur\ Stimulation\r\n\ der\ Schaltung\ werden\ durch\ die\ Methode\ <CODE>setInputEventsX()</CODE>\r\n\ erzeugt.\r\n\ Zum\ Testen\ Ihrer\ Klassen\ <CODE>Nand</CODE>,\ <CODE>Nor</CODE>,\r\n\ <CODE>Or</CODE>,\ <CODE>And</CODE>,\ <CODE>Exor</CODE>,\r\n\ <CODE>Buf</CODE>,\ <CODE>Not</CODE>,\ <CODE>FF</CODE>,\ <CODE>Latch</CODE>,\r\n\ <CODE>Signal</CODE>,\ <CODE>Event</CODE>,und\ <CODE>EventQueue</CODE>\r\n\ m\uFFFDssen\ Sie\ einfach\ nur\ eine\ Instanz\ dieser\ Klasse\ erzeugen\ und\ dann\r\n\ die\ Methode\ <CODE>simulate()</CODE>\ aufrufen.\r\n\ @author\ Christian\ Hochberger,\ TU\ Dresden\r\n\ @version\ 1.0\ Erste\ Fassung\r\n
comment1.params=version
comment1.target=FullTimingSimulator(int)
comment1.text=\r\n\ Konstruktor,\ der\ die\ zu\ simulierende\ Schaltung\ aufbaut,\ den\ Ruhezustand\r\n\ ermittelt\ und\ die\ Eingabe-Events\ erzeugt.\r\n\ Simuliert\ wird\ je\ nach\ Argument\ eine\ der\ drei\ vorgegebenen\ Schaltungen\r\n\ \ 1\ \=\ Einfacher\ Multiplexer\ 4\ zu\ 1\ \r\n\ \ 2\ \=\ Einfacher\ synchroner,\ r\uFFFDcksetzbarer\ Z\uFFFDhler\ mit\ 4\ Bit\r\n\ \ 3\ \=\ Komplexe\ Schaltung\ mit\ einem\ Z\uFFFDhler\ vielen\ Latches\ und\r\n\ \ \ \ \ \ einigen\ Multiplexern\r\n
comment10.params=
comment10.target=void\ setInputEvents1()
comment10.text=\r\n\ Diese\ Methode\ erzeugt\ eine\ Reihe\ von\ Eingabe-Events,\ die\ dann\ zur\r\n\ Stimulation\ der\ Schaltung\ dienen.\ \ Die\ Events\ werden\ durch\ ihren\r\n\ eigenen\ Konstruktor\ in\ die\ EventQueue\ eingetragen,\ so\ dass\ hier\ nur\r\n\ das\ Erzeugen\ der\ Events\ zu\ sehen\ ist.\r\n\ Jedes\ Event\ bekommt\ beim\ Erzeugen\ das\ betroffene\ Signal,\ den\ Zeitpunkt\r\n\ und\ den\ <bold>neuen\ Wert</bold>\ mit.\r\n
comment11.params=
comment11.target=void\ setInputEvents2()
comment11.text=\r\n\ Ebenfalls\ die\ Erzeugung\ der\ Stimuli\ f\uFFFDr\ die\ zweite\ eingebaute\ Schaltung\r\n\r\n
comment12.params=
comment12.target=void\ setInputEvents3()
comment12.text=\r\n\ Ebenfalls\ die\ Erzeugung\ der\ Stimuli\ f\uFFFDr\ die\ dritte\ eingebaute\ Schaltung\r\n\r\n
comment13.params=
comment13.target=void\ simulate()
comment13.text=\r\n\ Diese\ Methode\ f\uFFFDhrt\ die\ eigentliche\ Simulation\ durch.\ Dazu\ wird\r\n\ gepr\uFFFDft,\ ob\ in\ der\ EventQueue\ noch\ weitere\ Events\ vorhanden\ sind.\ Ist\r\n\ dies\ der\ Fall,\ dann\ wird\ das\ n\uFFFDchste\ anstehende\ Event\ behandelt.\ Dazu\r\n\ muss\ das\ Event\ die\ Methode\ propagate()\ zur\ Verf\uFFFDgung\ stellen,\ die\r\n\ dann\ das\ betroffene\ Signal\ informiert.\r\n
comment14.params=args
comment14.target=void\ main(java.lang.String[])
comment14.text=\r\n\ Main\ Methode\ dieser\ Klasse.\ Sie\ m\uFFFDssen\ das\ im\ Moment\ noch\ nicht\r\n\ verstehen.\ Diese\ Methode\ wird\ ben\uFFFDtigt,\ wenn\ Sie\ den\ Simulator\ ohne\r\n\ BlueJ\ laufen\ lassen\ wollen.\ Wenn\ Sie\ diese\ Klasse\ in\ BlueJ\ nutzen,\r\n\ dann\ ignorieren\ Sie\ diese\ Methode\ einfach.\r\n\ \r\n\ Wenn\ Sie\ die\ verschiedenen\ Schaltungen\ testen\ wollen,\ dann\ m\uFFFDssen\r\n\ Sie\ den\ Parameter\ des\ Konstruktors\ entsprechend\ \uFFFDndern.\ Das\ k\uFFFDnnen\r\n\ Sie\ nat\uFFFDrlich\ auch\ durch\ Auswertung\ der\ Kommandozeilenparameter\ tuen.\r\n
comment2.params=inputs\ select\ nselect\ out
comment2.target=void\ buildMux(Signal[],\ Signal[],\ Signal[],\ Signal)
comment2.text=\r\n\ Diese\ Methode\ konstruiert\ einen\ Multiplexer\ aus\ den\ gegebenen\r\n\ Eingangssignalen,\ den\ Steursignalen\ (und\ ihrer\ Negation)\ und\ legt\ den\r\n\ Ausgang\ an\ das\ angegebene\ Signal.\ Die\ gegebene\ Methode\ funktioniert\r\n\ maximal\ bis\ zu\ vier\ Eing\uFFFDngen.\r\n
comment3.params=clk\ reset\ outputs
comment3.target=void\ buildSynCounter(Signal,\ Signal,\ Signal[])
comment3.text=\r\n\ Diese\ Methode\ konstruiert\ einen\ synchronen,\ r\uFFFDcksetzbaren\ Z\uFFFDhler.\r\n\ \uFFFDbergeben\ werden\ ein\ Taktsignal,\ ein\ Reset-Signal\ und\ ein\ Array\ mit\r\n\ Augangssignalen.\ \uFFFDber\ die\ Gr\uFFFD\uFFFDe\ dieses\ Arrays\ wird\ automatisch\ auch\r\n\ die\ Breite\ des\ Z\uFFFDhlers\ bestimmt.\r\n
comment4.params=
comment4.target=void\ buildCircuit1()
comment4.text=\r\n\ Diese\ Methode\ konstruiert\ die\ Schaltung.\ Die\ erzeugten\ Gatter\ und\ die\r\n\ inneren\ Signale\ sind\ nur\ in\ dieser\ Methode\ bekannt,\ da\ sie\ im\ Verlauf\r\n\ der\ Simulation\ implizit\ durch\ die\ Events,\ bzw.\ die\ Signale\ angesprochen\r\n\ werden.Simuliert\ wird\ ein\ einfacher\ Multiplexer\ der\ einen\ aus\ vier\r\n\ Eing\uFFFDngen\ ausw\uFFFDhlt.\r\n
comment5.params=
comment5.target=void\ buildCircuit2()
comment5.text=\r\n\ Diese\ Methode\ konstruiert\ eine\ weitere\ Schaltung.\ \ Simuliert\ wird\r\n\ ein\ einfacher\ vier\ Bit\ synchroner\ Z\uFFFDhler.\r\n
comment6.params=
comment6.target=void\ buildCircuit3()
comment6.text=\r\n\ Diese\ Methode\ konstruiert\ die\ dritte\ m\uFFFDgliche\ Schaltung.\ \ Diese\ ist\r\n\ sehr\ kompliziert\ (enth\uFFFDlt\ ca.\ 150\ Gatter).\ Die\ genaue\ Funktion\r\n\ k\uFFFDnnen\ Sie\ ja\ mal\ versuchen\ herauszubekommen.\r\n
comment7.params=
comment7.target=void\ findSteadyState1()
comment7.text=\r\n\ Diese\ Methode\ ermittelt\ den\ Ruhezustand\ der\ Schaltung.\ Dazu\ werden\r\n\ vern\uFFFDnftige\ Initialwerte\ an\ die\ Eing\uFFFDnge\ angelegt.\ Diese\ Initialwerte\r\n\ m\uFFFDssen\ mindestens\ einmal\ durch\ die\ Schaltung\ propagiert\ werden,\r\n\ bis\ sich\ ein\ stabiler\ Zustand\ einstellt.\ Um\ das\ festzustellen\ gibt\r\n\ es\ verschiedene\ Methoden\ (im\ Gatter\ mitz\uFFFDhlen,\ wie\ oft\ sich\ der\ Wert\r\n\ \uFFFDndert.\ Im\ Signal\ mitz\uFFFDhlen,\ wie\ oft\ es\ ge\uFFFDndert\ wurde).\r\n\ Bei\ diesem\ Propagieren\ darf\ nat\uFFFDrlich\ nicht\ mit\ den\ Zeitverz\uFFFDgerungen\r\n\ gearbeitet\ werden.\ \ Sie\ k\uFFFDnnen\ also\ im\ Grunde\ die\ Wert-Propagierung\r\n\ aus\ der\ ersten\ Teilaufgabe\ benutzen.\r\n
comment8.params=
comment8.target=void\ findSteadyState2()
comment8.text=\r\n\ Genau\ wie\ die\ vorhergehende\ Methode\ nur\ f\uFFFDr\ die\ Schaltung\ zwei\r\n
comment9.params=
comment9.target=void\ findSteadyState3()
comment9.text=\r\n\ Genau\ wie\ die\ vorhergehende\ Methode\ nur\ f\uFFFDr\ die\ Schaltung\ drei\r\n
numComments=15
